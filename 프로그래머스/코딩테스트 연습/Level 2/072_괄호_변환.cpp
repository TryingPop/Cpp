/*
날짜 : 2024. 8. 16
이름 : 배성훈
내용 : 괄호 변환
	소스코드에 괄호의 개수는 맞지만 짝이 맞지 않은 형태로 작성되어
	오류가 나는 것을 알게 되었다

	소스코드에 작성된 모든 괄호를 뽑아서 올바른
	순서대로 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 한다

	'('와 ')'로만 이루어진 문자열이 있을 때,
	'('의 개수와 ')'의 개수가 같다면 균형잡힌 괄호 문자열이라 한다

	여기서 '('와 ')'의 괄호의 짝도 모두 맞을 경우에는 
	올바른 괄호 문자열이라고 부른다

	'('와 ')'로만 이루어진 문자열 w가 균형잡힌 괄호 문자열 이라면
	다음과 같은 과정을 통해 올바른 괄호 문자열로 변환하려고 한다

	1. 입력이 빈 문자열인 경우, 빈 문자열을 반환
	2. 문자열 w를 두 균형잡힌 괄호 문자열 u와 v로 분리하려 한다
		단 u는 균형잡힌 괄호 문자열로 더이상 분리할 수 없고,
		v는 빈 문자열일 수 있다
	3. 문자열 u가 올바른 괄호 문자열이라면 문자열 v에 대해 1단계부터 다시 수행한다
		수행한 결과 문자열을 u에 이어붙인다
	4. 문자열 u가 올바른 괄호 문자열이 아니라면 아래 과정을 수행한다
		빈 문자열에 첫 번째 문자로 '('를 붙인다
		v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙인다
		')'를 다시 붙인다
		u의 첫 번째와 마지막 문자를 제거하고 
		나머지 문자열의 괄호 방향을 뒤집어서 뒤에 이어 붙인다
		생성된 문자열을 반환한다

	균형잡힌 괄호 문자열 p가 매개변수로 주어질 때,
	주어진 알고리즘을 수행해 올바른 괄호 문자열로 변환한 결과를
	return 하는 solution 함수 구현

	p는 '('와 ')'로만 이루어진 문자열이며 
	길이는 2 이상 1'000 이하인 짝수

	문자열 p를 이루는 '('와 ')'의 개수는 항상 같다

	만약 p가 이미 올바른 괄호 문자열이라면 그대로 return 하면 된다

	parameter
	"()))((()"


	return
	"()(())()"


	sol
	"()))((()"는 올바른 괄호 문자열이 아니다
	그래서 u, v를 구분한다
	u는 "()" 이고 올바른 괄호 문자열이다
	그래서 u 이외 부분 v = "))((()"에 대해 괄호 검사를 진행한다

	"))((()"도 올바른 괄호 문자열이 아니므로 다시 u, v로 구분한다
	그러면 u는 "))(("이고, v는 "()"이다
	u가 올바른 괄호 문자열이 아니므로,

	문자열 앞에 "("를 넣고 v = "()"에 괄호 검사를 한다
	v가 올바른 괄호 문자열이므로 "()"를 반환하고

	"(()"가 된다
	그리고 뒤에 ')'를 이어 붙이면 "(())"이고 
	u = "))(("에 대해 앞 뒤로 제거하고 괄호를 뒤집으면 "()"이 된다
	그래서 이어 붙이면
	"))((()"는 "(())()"이된다

	그리고 앞의 "()"를 이어붙이면 결과적으로 "()(())()"이 된다
*/

#include <string>

using namespace std;

inline bool ChkCorrect(string& _str)
{

	/*
	
	올바른 괄호 문자열인지 확인
	*/
	int cnt = 0;

	for (int i = 0; i < _str.length(); i++)
	{

		if (_str[i] == '(') cnt++;
		else 
		{

			if (cnt) cnt--;
			else return false;
		}
	}

	return cnt == 0;
}

inline int GetU(string& _str)
{

	/*
	
	첫 번째 문자를 포함하는 가장작은 균형잡힌 괄호 문자열의
	끝 인덱스 반환

	찾지 못하면 -1을 반환 
	그런데 입력이 균형잡힌 괄호 문자열이면 -1은 반환되지 않는다
	*/
	int cnt = 0;
	for (int i = 0; i < _str.length(); i++)
	{

		if (_str[i] == '(') cnt++;
		else cnt--;

		if (cnt == 0) return i + 1;
	}

	// _str이 균형잡힌 문자열이면 여기로 올일 없다
	return -1;
}

inline void Reverse(string& _str)
{

	/*
	
	괄호 뒤집기
	문제에서 요구하는 뒤집기는 "))((("인 경우
	"((())"이 아닌 "(()))"이다
	*/
	for (char& c : _str)
	{

		if (c == ')') c = '(';
		else c = ')';
	}
}

inline string DFS(string _str)
{

	// 올바른 문자열인지 확인한 후 반환
	if (ChkCorrect(_str)) return _str;

	// u 찾기
	int uLen = GetU(_str);
	string u = _str.substr(0, uLen);
	string v = _str.substr(uLen);

	// u가 올바른 문자열인지 확인
	if (ChkCorrect(u)) return u + DFS(v);

	// u가 올바른 문자열이 아니면 4번 진행
	v = "(" + DFS(v) + ")";
	u = u.substr(1, uLen - 2);
	Reverse(u);

	return v + u;
}

string solution(string _p)
{

	/*
	
	구현, 문자열
	*/
	string answer = DFS(_p);
	return answer;
}